---
layout:     post
title:      Leetcode刷题
subtitle:   算法和解决方法
date:       2020-03-14
author:     Doublefierce
header-img: img/bg-post.jpg
catalog: true
tags:
    - Leetcode
---


### 1.两数之和

使用查找表来解决该问题

设置一个map容器record用来记录元素的值与索引，然后遍历数组nums

	- 每次遍历时使用临时变量complement用来保存目标值与当前值的差值
	-  在此次遍历中查找record, 查看是否有与complement一致的值，如果查找成功则返回查找值的索引值与当前变量的值i
	-  如果未找到，则在record保存该元素与索引值i

### 21.合并两个有序链表

```
首先，设定一个虚拟节点 dummy 用来存储结果，循环对比 L1 和 L2 节点上的数字，通过调整 p节点的 next 指针来调整 dummy 的结果
```

### 19.删除链表的倒数第n个节点

```
- 首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)个结点那里。我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。

- 我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。

```

### 105.用前序和中序遍历序列构建二叉树

```
前序/后序+中序遍历可以确定一棵唯一二叉树
- 前序中左起第一位肯定是根结点，以此为根据找到中序中根结点的位置 rootIdx
- 中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为 int leftLen = rootIdx - leftIdx
- 前序中结点分布应该是：[根结点，左子树结点，右子树结点]
- 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围

如果我们要递归生成二叉树的话，下一层递归应该是：
- 左子树：root->left = buildTree(前序左子树范围，前序起始下标，前序结束下标，中序开始下标);；
- 右子树：root->right = buildTree(前序左子树范围，前序起始下标，前序结束下标，中序开始下标);。

两个注意点：
- 每一层递归都要返回当前根结点root；
- 为了避免在递归过程中线性查找，可以借助 哈希表 来储存中序的元素与下标
```

### 191.位1的个数

```
方法1:循环和位移动
方法2：位操作的小技巧
观察一下 n 与 n-1 这两个数的二进制表示：对于 n-1 这个数的二进制来说，相对于 n 的二进制，它的最末位的一个 1 会变成 0，最末位一个 1 之后的 0 会全部变成 1，其它位相同不变。
比如 n = 8888，其二进制为 10001010111000
则 n – 1 = 8887 ，其二进制为 10001010110111
通过按位与操作后：n & (n-1) = 10001010110000
也就是说：通过 n&(n-1)这个操作，可以起到 消除最后一个1 的作用。
所以可以通过执行 n&(n-1) 操作来消除 n 末尾的 1 ，消除了多少次，就说明有多少个 1 
```

### 41.缺失的第一个正数

```
使用桶排序的思路，即 “一个萝卜一个坑”，就可以解决。
我们可以把数组进行一次“排序”，“排序”的规则是：如果这个数字 i 落在“区间范围里”，i 就应该放在索引为 i – 1 的位置上。
```

### 23.合并K个排序链表

```
利用最小堆的概念，用heap(堆)这种数据结构，也就是 java 里面的 PriorityQueue
取每个 Linked List 的最小节点放入一个 heap 中，排序成最小堆。然后取出堆顶最小的元素，放入输出的合并 List 中，然后将该节点在其对应的 List 中的下一个节点插入到 heap 中，循环上面步骤，以此类推直到全部节点都经过 heap。

由于 heap 的大小为始终为 k ，而每次插入的复杂度是 logk ，一共插入了 nk 个节点。时间复杂度为 O(nklogk)，空间复杂度为O(k)。
```

## 数组、字符串

### 242. 有效的字母异位词

```
长度为26的字符数组，出现在第一个字符串的数字加1，出现在第二个字符串的数字减1，判断每个字符的个数是否为0
```

## 链表

### 25.K个一组翻转链表

```
用3个指针prev, curr, next分别代表了前一个结点，当前节点和下一个节点，每次将curr指向的下一个节点保存到next指针，然后curr指针指向prev, 接着curr和prev一起前进一步，接着不断的执行之前的步骤，知道将当前这组元素全部翻转完毕
```

## 栈

### 20.有效的括号

```
利用一个栈，不断的往里压左括号，一旦遇到了一个右括号，就把栈顶的元素弹出来，表示这是一个合法的组合，以此类推，知道最后看栈里还有没有左括号剩余
```

### 739.每日温度

借助栈来解决， **递减栈** ：

```

- 为了便于计算索引差，栈存放的应当是元素的索引值，遍历整个数组，将当前数字和栈顶元素做比较。
- 如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是递减栈，所以需要取出栈顶元素，由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，直接求出下标差就是二者的距离。
- 继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止（栈为空），然后将数字入栈，这样就可以一直保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来。
```

## 双端队列

### 239.滑动窗口最大值

```
将新的数据加入到窗口的尾部，将旧的数据从窗口头部删除
```

## 树

### 230. 二叉搜索中第K小的元素

```
中序遍历
```

## 优先队列

### 347.前K个高频元素

## 图

### 785.判断二分图

## 前缀树

### 212.单词搜索II

## 线段树

### 315.计算右侧小于当前元素的个数

## 树状数组

### 308. 二维区域和检索

